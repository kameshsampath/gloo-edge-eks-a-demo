{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gloo Edge EKS-A Tutorial \u00b6 As part of this short tutorial we will explore how to setup and use Gloo Edge with EKS-A cluster. At the end of this short tutorial you would have learnt, Setup EKS-A cluster Deploy Gloo Edge Enterprise on to EKS-A cluster Integrate Gloo Edge with AWS Lambda and Do RateLimiting Do WAF Integrate Gloo Edge with Cloud Native Application and Do RateLimiting Do WAF Do CORS","title":"Overview"},{"location":"#gloo-edge-eks-a-tutorial","text":"As part of this short tutorial we will explore how to setup and use Gloo Edge with EKS-A cluster. At the end of this short tutorial you would have learnt, Setup EKS-A cluster Deploy Gloo Edge Enterprise on to EKS-A cluster Integrate Gloo Edge with AWS Lambda and Do RateLimiting Do WAF Integrate Gloo Edge with Cloud Native Application and Do RateLimiting Do WAF Do CORS","title":"Gloo Edge EKS-A Tutorial"},{"location":"blog/","text":"Gloo Edge on EKS-A in 5 minutes \u00b6 Overview \u00b6 In my personal opinion there is always a myth that API Gateways are for cloud or can only with be used with public cloud providers. But that is not the truth, API Gateways are suited for any architecture public, private or hybrid cloud. The only basic requirement for it is to have API ;). Gloo Edge is an open-source, flexible and extensible API Gateway built on Envoy Proxy for microservices environments. Gloo Edge configures the behavior of the Envoy Proxy data plane to ensure secure application connectivity and policy based traffic management. In this blog post, let us burst the myth and explore how we can setup API Gateway with Gloo Edge in hybrid cloud infrastructure with EKS-A and connect a AWS Lambda function using Gloo Edge. What we need ? \u00b6 Cloud Infrastructure \u00b6 VMWare Cloud - Infrastructure to deploy eks-a Kubernetes cluster. AWS Account - An AWS account with permissions to create and execute AWS Lambda Function. Tools \u00b6 eks-a glooctl jq kubectl kustomize httpie AWS CLI v2 Lastly you might need Gloo Edge Enterprise License Key to deploy Gloo Edge on to the eks-a infrastructure. Demo Sources \u00b6 Clone the demo sources from the GitHub respository, git clone https://github.com/kameshsampath/gloo-edge-eks-a-demo cd gloo-edge-eks-a-demo For convinience, we will refer the clone demo sources folder as $DEMO_HOME , export DEMO_HOME = \" $( pwd ) \" Ensure Environment \u00b6 We will set the following environment variables for convinience and we will be referring to these variables in upcoming sections. export AWS_ACCESS_KEY_ID = <your aws access key> export AWS_SECRET_ACCESS_KEY = <your aws secret key> export AWS_DEFAULT_REGION = <the aws region to use for the resources> EKS-A Cluster \u00b6 To create the EKS cluster run the follwing command, eks-a create cluster -f gloo-edge.yaml # (1) gloo-edge.yaml - will be generated using the eks-a generate command. For more information on the command please refer to TODO Link to eks-a docs . Configure Storage Class \u00b6 The demo clusters does not have any default storage provisoners or storage class defined. For this demo we will use rancher\u2019s local-path-provisoner . kubectl apply \\ -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml Wait for the storage provisioner to be ready, kubectl rollout status -n local-path-storage deploy/local-path-provisioner --timeout = 60s Once the provisioner is installed, check the same using the command kubectl get sc . NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE local-path rancher.io/local-path Delete WaitForFirstConsumer false 6d13h As you have noticed from the command output about local-path is not the default storage class. Default storage class helps in dynamic provisioning of the Kubernetes Persistent Volumes. Let us set it as default storage class so that any new PVC requests will be created using this Storage class\u2019 underlying storage. kubectl patch storageclass local-path \\ -p '{\"metadata\": {\"annotations\":{\"storageclass.kubernetes.io/is-default-class\":\"true\"}}}' Running the kubectl get sc again shows the local-path as the default provisoner, NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE local-path ( default ) rancher.io/local-path Delete WaitForFirstConsumer false 6d13h Install Gloo Edge Enterprise \u00b6 Download and install latest glooctl by running, curl -sL https://run.solo.io/gloo/install | sh Add glooctl to the system path, export PATH = $HOME /.gloo/bin: $PATH Gloo Edge proxy is a Kubernetes service of type LoadBalancer , for the purpose of this blog we will configure it to be of type NodePort using the install-ee-values.yaml as shown below, gloo : settings : writeNamespace : gloo-system watchNamespace : - gloo-system - fruits-app gatewayProxies : gatewayProxy : service : type : NodePort httpNodePort : 30080 # (1) httpsNodePort : 30443 # (2) Use 30080 as NodePort to access the Gloo Proxy Use 30443 as NodePort to access the Gloo Proxy glooctl install gateway enterprise \\ --license-key \" $GLOO_LICENSE_KEY \" \\ --values \" $DEMO_HOME /cluster/install-ee-values.yaml\" Note You can safely ignore the helm warnings It will take few minutes for the gloo to be ready, try the command glooctl check to verify the status. Once the gloo edge is deployed check if Gloo Edge is functional, glooctl check A successful gloo edge installation should show an output like, Checking deployments... OK Checking pods... OK Checking upstreams... OK Checking upstream groups... OK Checking auth configs... OK Checking rate limit configs... OK Checking VirtualHostOptions... OK Checking RouteOptions... OK Checking secrets... OK Checking virtual services... OK Checking gateways... OK Checking proxies... OK Checking rate limit server... OK No problems detected. I0818 09:29:26.773174 6734 request.go:645] Throttling request took 1.041899775s, request: GET:https://127.0.0.1:57778/apis/storage.k8s.io/v1?timeout=32s Detected Gloo Federation! Deploy AWS Lambda Function \u00b6 With us having created an eks-a cluster and deployed Gloo Edge on to it successfully, let us now create AWS Lambda function and use Gloo Edge to invoke it. Create AWS IAM Role \u00b6 aws iam create-role --role-name gloo-edge-eks-a-lambdaex \\ --assume-role-policy-document \"file:// $DEMO_HOME /apps/lambda/trust-policy.json\" Save the Role ARN environment variable, export ROLE_ARN = $( aws iam get-role --role-name gloo-edge-eks-a-lambdaex | jq -r .Role.Arn ) Attach the AWSLambdaBasicExecutionRole to our role, aws iam attach-role-policy --role-name gloo-edge-eks-a-lambdaex \\ --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole Create Lambda Function \u00b6 The demo already has ready to deploy simple nodejs hello world application, exports . handler = async ( event ) => { const response = { statusCode : 200 , body : { \"message\" : `Hello ${ event . user ? event . user : \"there\" } , welcome to Gloo Edge with Lambda.,` }, }; return response ; }; Let us deploy that function using AWS Lambda, aws lambda create-function --function-name gloo-edge-hello-lambda \\ --zip-file \"fileb:// $DEMO_HOME /apps/lambda/function.zip\" \\ --handler index.handler \\ --runtime nodejs14.x \\ --role \" $ROLE_ARN \" Let us make sure our function works, aws lambda invoke \\ --cli-binary-format raw-in-base64-out \\ --function-name gloo-edge-hello-lambda \\ --payload '{\"user\": \"tom\"}' \\ response.json If the function has executed sucessfully, the $DEMO_HOME/response.json should have the following content, { \"statusCode\" : 200 , \"body\" : { \"message\" : \"Hello tom, welcome to Gloo Edge with Lambda.,\" } } Gloo Edge \u00b6 We have now deployed the AWS Lambda function, let us now create the necessary Gloo Edge resources that will allow configure and access the Lambda via Gloo Edge Gateway. To have more understanding on core concepts check the Gloo Edge documentation . As part of this short demo we will, Create AWS Secret Create Gloo Upstream Create Gloo Virtual Services Create AWS Secret \u00b6 We need to create Kubernetes secret that holds the AWS Keys. This secret will be used by Gloo Edge invoke the AWS Lambda function, glooctl create secret aws \\ --name = gloo-eks-a-demo \\ --access-key = \" $AWS_ACCESS_KEY_ID \" \\ --secret-key = \" $AWS_SECRET_ACCESS_KEY \" Note If you have not set the environment variables $AWS_ACCESS_KEY_ID and $AWS_SECRET_ACCESS_KEY , the value from $HOME/.aws/credentials will be used. You can check the created credentials by, kubectl get secrets -n gloo-system gloo-eks-a-demo -o yaml Create Upstream \u00b6 As part of this section we will create an Gloo Upstream that will allow the Virutal Service to talk to AWS Lambda via Gloo Edge Gateway, Important If you are default region is other than us-east-1 , ensure to set the value for $AWS_DEFAULT_REGION to the region of your choice before running the upstream create command. glooctl create upstream aws \\ --name = \"gloo-edge-hello-lambda\" \\ --aws-region = \" $AWS_DEFAULT_REGION \" \\ --aws-secret-name = gloo-eks-a-demo Check the status of the upstream, glooctl get upstream gloo-edge-hello-lambda +------------------------+------------+----------+--------------------------------+ | UPSTREAM | TYPE | STATUS | DETAILS | +------------------------+------------+----------+--------------------------------+ | gloo-edge-hello-lambda | AWS Lambda | Accepted | region: ap-south-1 | | | | | secret: | | | | | gloo-system.gloo-eks-a-demo | | | | | functions: | | | | | - gloo-edge-hello-lambda | | | | | - my-function | | | | | | +------------------------+------------+----------+--------------------------------+ Create Route \u00b6 A Route is a Gloo Virutal Service resource that allows us to access the API i.e. the services that are deployed on to Kubernetes. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : greeter namespace : gloo-system spec : displayName : AWS Lambda Greeter virtualHost : domains : # (1) - \"example.com\" routes : # Application Routes # ------------ - matchers : - prefix : /greet # (2) routeAction : single : destinationSpec : aws : # (3) logicalName : gloo-edge-hello-lambda # (4) upstream : # (5) name : gloo-edge-hello-lambda namespace : gloo-system Domains that will be allowed by the Gateway The prefix to access the API The destination spec type in this case AWS Lambda function named gloo-edge-hello-lambda The upstream that wil be used to route the request Let us create the virutal service, kubectl apply -n gloo-system -f $DEMO_HOME /apps/lambda/gloo/virtual-service.yaml Check the status of the virtual service glooctl get vs greeter +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+ | VIRTUAL SERVICE | DISPLAY NAME | DOMAINS | SSL | STATUS | LISTENERPLUGINS | ROUTES | +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+ | greeter | AWS Lambda Greeter | example.com | none | Accepted | | /greet -> | | | | | | | | gloo-system.gloo-edge-hello-lambda | | | | | | | | (upstream) | +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+ Gloo Proxy URL \u00b6 We need to use the Gloo proxy to access the API, we can use glooctl to get the proxy URL, export GLOO_PROXY_URL = $( glooctl proxy url ) Important glooctl proxy url always returns the hostname of the Kubernetes nodes. You can check the hostnames using the command kubectl get nodes Resolve Nodes via /etc/hosts \u00b6 Note You can ignore this section if your nodes are resolvable by their names Assuming that your VMC environment that does not have DNS resolver to resolve the EKS-A Kubernetes node names. In such caes we need to add the node names to the /etc/hosts file for them to be resolved. kubectl get nodes \\ -ojsonpath = \" {'#GLOO EDGE DEMO\\n'}{range .items[*]}{.status.addresses[?(@.type == 'ExternalIP')].address}{'\\t'}{.metadata.name}{'\\n'}{end}\" ) \\ | sudo tee --append /etc/hosts Invoke Function \u00b6 Check if the API is accessible, http --body POST $GLOO_PROXY_URL /greet 'Host: example.com' user = tom Note We have to use the host header \u2018Host: example.com\u2019 as we have restricted the gateway domains of the Virtual Service to example.com only. In the next chapter we will use the wildcard domain that will allow all the domains. The command should return a list of fruits as shown, { \"body\" : { \"message\" : \"Hello tom, welcome to Gloo Edge with Lambda.,\" }, \"statusCode\" : 200 } Tip Try the same request as show below to see the other repsonse headers http POST $GLOO_PROXY_URL /greet 'Host: example.com' user = tom Cleanup \u00b6 Delete the virtual service, glooctl delete vs greeter Delete the upstream, glooctl delete upstream gloo-edge-hello-lambda Delete AWS Lambda Function, aws lambda delete-function --function-name gloo-edge-hello-lambda Detach policy, aws iam detach-role-policy --role-name gloo-edge-eks-a-lambdaex \\ --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole Delete the Role, aws iam delete-role --role-name gloo-edge-eks-a-lambdaex Remove entries from /etc/hosts file, export NODE_COUNT = $( kubectl get nodes --no-headers | wc -l ) sudo sed -i -e '/#GLOO EDGE DEMO/,+' \" ${ NODE_COUNT } d\" /etc/hosts Summary \u00b6 As part of this short blog we explored how to , Create a EKS-A cluster Deploy Gloo Edge Use GLoo Edge to invoke an AWS Lambda function Gloo Edge is not restricted to AWS Lambda, it can also be used to connect traditional microservices. Head over to the tutorial to learn more on what other thigns you can do with Gloo Edge. Any other CTA","title":"Gloo Edge on EKS-A in 5 minutes"},{"location":"blog/#gloo-edge-on-eks-a-in-5-minutes","text":"","title":"Gloo Edge on EKS-A in 5 minutes"},{"location":"blog/#overview","text":"In my personal opinion there is always a myth that API Gateways are for cloud or can only with be used with public cloud providers. But that is not the truth, API Gateways are suited for any architecture public, private or hybrid cloud. The only basic requirement for it is to have API ;). Gloo Edge is an open-source, flexible and extensible API Gateway built on Envoy Proxy for microservices environments. Gloo Edge configures the behavior of the Envoy Proxy data plane to ensure secure application connectivity and policy based traffic management. In this blog post, let us burst the myth and explore how we can setup API Gateway with Gloo Edge in hybrid cloud infrastructure with EKS-A and connect a AWS Lambda function using Gloo Edge.","title":"Overview"},{"location":"blog/#what-we-need","text":"","title":"What we need ?"},{"location":"blog/#cloud-infrastructure","text":"VMWare Cloud - Infrastructure to deploy eks-a Kubernetes cluster. AWS Account - An AWS account with permissions to create and execute AWS Lambda Function.","title":"Cloud Infrastructure"},{"location":"blog/#tools","text":"eks-a glooctl jq kubectl kustomize httpie AWS CLI v2 Lastly you might need Gloo Edge Enterprise License Key to deploy Gloo Edge on to the eks-a infrastructure.","title":"Tools"},{"location":"blog/#demo-sources","text":"Clone the demo sources from the GitHub respository, git clone https://github.com/kameshsampath/gloo-edge-eks-a-demo cd gloo-edge-eks-a-demo For convinience, we will refer the clone demo sources folder as $DEMO_HOME , export DEMO_HOME = \" $( pwd ) \"","title":"Demo Sources"},{"location":"blog/#ensure-environment","text":"We will set the following environment variables for convinience and we will be referring to these variables in upcoming sections. export AWS_ACCESS_KEY_ID = <your aws access key> export AWS_SECRET_ACCESS_KEY = <your aws secret key> export AWS_DEFAULT_REGION = <the aws region to use for the resources>","title":"Ensure Environment"},{"location":"blog/#eks-a-cluster","text":"To create the EKS cluster run the follwing command, eks-a create cluster -f gloo-edge.yaml # (1) gloo-edge.yaml - will be generated using the eks-a generate command. For more information on the command please refer to TODO Link to eks-a docs .","title":"EKS-A Cluster"},{"location":"blog/#configure-storage-class","text":"The demo clusters does not have any default storage provisoners or storage class defined. For this demo we will use rancher\u2019s local-path-provisoner . kubectl apply \\ -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml Wait for the storage provisioner to be ready, kubectl rollout status -n local-path-storage deploy/local-path-provisioner --timeout = 60s Once the provisioner is installed, check the same using the command kubectl get sc . NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE local-path rancher.io/local-path Delete WaitForFirstConsumer false 6d13h As you have noticed from the command output about local-path is not the default storage class. Default storage class helps in dynamic provisioning of the Kubernetes Persistent Volumes. Let us set it as default storage class so that any new PVC requests will be created using this Storage class\u2019 underlying storage. kubectl patch storageclass local-path \\ -p '{\"metadata\": {\"annotations\":{\"storageclass.kubernetes.io/is-default-class\":\"true\"}}}' Running the kubectl get sc again shows the local-path as the default provisoner, NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE local-path ( default ) rancher.io/local-path Delete WaitForFirstConsumer false 6d13h","title":"Configure Storage Class"},{"location":"blog/#install-gloo-edge-enterprise","text":"Download and install latest glooctl by running, curl -sL https://run.solo.io/gloo/install | sh Add glooctl to the system path, export PATH = $HOME /.gloo/bin: $PATH Gloo Edge proxy is a Kubernetes service of type LoadBalancer , for the purpose of this blog we will configure it to be of type NodePort using the install-ee-values.yaml as shown below, gloo : settings : writeNamespace : gloo-system watchNamespace : - gloo-system - fruits-app gatewayProxies : gatewayProxy : service : type : NodePort httpNodePort : 30080 # (1) httpsNodePort : 30443 # (2) Use 30080 as NodePort to access the Gloo Proxy Use 30443 as NodePort to access the Gloo Proxy glooctl install gateway enterprise \\ --license-key \" $GLOO_LICENSE_KEY \" \\ --values \" $DEMO_HOME /cluster/install-ee-values.yaml\" Note You can safely ignore the helm warnings It will take few minutes for the gloo to be ready, try the command glooctl check to verify the status. Once the gloo edge is deployed check if Gloo Edge is functional, glooctl check A successful gloo edge installation should show an output like, Checking deployments... OK Checking pods... OK Checking upstreams... OK Checking upstream groups... OK Checking auth configs... OK Checking rate limit configs... OK Checking VirtualHostOptions... OK Checking RouteOptions... OK Checking secrets... OK Checking virtual services... OK Checking gateways... OK Checking proxies... OK Checking rate limit server... OK No problems detected. I0818 09:29:26.773174 6734 request.go:645] Throttling request took 1.041899775s, request: GET:https://127.0.0.1:57778/apis/storage.k8s.io/v1?timeout=32s Detected Gloo Federation!","title":"Install Gloo Edge Enterprise"},{"location":"blog/#deploy-aws-lambda-function","text":"With us having created an eks-a cluster and deployed Gloo Edge on to it successfully, let us now create AWS Lambda function and use Gloo Edge to invoke it.","title":"Deploy AWS Lambda Function"},{"location":"blog/#create-aws-iam-role","text":"aws iam create-role --role-name gloo-edge-eks-a-lambdaex \\ --assume-role-policy-document \"file:// $DEMO_HOME /apps/lambda/trust-policy.json\" Save the Role ARN environment variable, export ROLE_ARN = $( aws iam get-role --role-name gloo-edge-eks-a-lambdaex | jq -r .Role.Arn ) Attach the AWSLambdaBasicExecutionRole to our role, aws iam attach-role-policy --role-name gloo-edge-eks-a-lambdaex \\ --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole","title":"Create AWS IAM Role"},{"location":"blog/#create-lambda-function","text":"The demo already has ready to deploy simple nodejs hello world application, exports . handler = async ( event ) => { const response = { statusCode : 200 , body : { \"message\" : `Hello ${ event . user ? event . user : \"there\" } , welcome to Gloo Edge with Lambda.,` }, }; return response ; }; Let us deploy that function using AWS Lambda, aws lambda create-function --function-name gloo-edge-hello-lambda \\ --zip-file \"fileb:// $DEMO_HOME /apps/lambda/function.zip\" \\ --handler index.handler \\ --runtime nodejs14.x \\ --role \" $ROLE_ARN \" Let us make sure our function works, aws lambda invoke \\ --cli-binary-format raw-in-base64-out \\ --function-name gloo-edge-hello-lambda \\ --payload '{\"user\": \"tom\"}' \\ response.json If the function has executed sucessfully, the $DEMO_HOME/response.json should have the following content, { \"statusCode\" : 200 , \"body\" : { \"message\" : \"Hello tom, welcome to Gloo Edge with Lambda.,\" } }","title":"Create Lambda Function"},{"location":"blog/#gloo-edge","text":"We have now deployed the AWS Lambda function, let us now create the necessary Gloo Edge resources that will allow configure and access the Lambda via Gloo Edge Gateway. To have more understanding on core concepts check the Gloo Edge documentation . As part of this short demo we will, Create AWS Secret Create Gloo Upstream Create Gloo Virtual Services","title":"Gloo Edge"},{"location":"blog/#create-aws-secret","text":"We need to create Kubernetes secret that holds the AWS Keys. This secret will be used by Gloo Edge invoke the AWS Lambda function, glooctl create secret aws \\ --name = gloo-eks-a-demo \\ --access-key = \" $AWS_ACCESS_KEY_ID \" \\ --secret-key = \" $AWS_SECRET_ACCESS_KEY \" Note If you have not set the environment variables $AWS_ACCESS_KEY_ID and $AWS_SECRET_ACCESS_KEY , the value from $HOME/.aws/credentials will be used. You can check the created credentials by, kubectl get secrets -n gloo-system gloo-eks-a-demo -o yaml","title":"Create AWS Secret"},{"location":"blog/#create-upstream","text":"As part of this section we will create an Gloo Upstream that will allow the Virutal Service to talk to AWS Lambda via Gloo Edge Gateway, Important If you are default region is other than us-east-1 , ensure to set the value for $AWS_DEFAULT_REGION to the region of your choice before running the upstream create command. glooctl create upstream aws \\ --name = \"gloo-edge-hello-lambda\" \\ --aws-region = \" $AWS_DEFAULT_REGION \" \\ --aws-secret-name = gloo-eks-a-demo Check the status of the upstream, glooctl get upstream gloo-edge-hello-lambda +------------------------+------------+----------+--------------------------------+ | UPSTREAM | TYPE | STATUS | DETAILS | +------------------------+------------+----------+--------------------------------+ | gloo-edge-hello-lambda | AWS Lambda | Accepted | region: ap-south-1 | | | | | secret: | | | | | gloo-system.gloo-eks-a-demo | | | | | functions: | | | | | - gloo-edge-hello-lambda | | | | | - my-function | | | | | | +------------------------+------------+----------+--------------------------------+","title":"Create Upstream"},{"location":"blog/#create-route","text":"A Route is a Gloo Virutal Service resource that allows us to access the API i.e. the services that are deployed on to Kubernetes. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : greeter namespace : gloo-system spec : displayName : AWS Lambda Greeter virtualHost : domains : # (1) - \"example.com\" routes : # Application Routes # ------------ - matchers : - prefix : /greet # (2) routeAction : single : destinationSpec : aws : # (3) logicalName : gloo-edge-hello-lambda # (4) upstream : # (5) name : gloo-edge-hello-lambda namespace : gloo-system Domains that will be allowed by the Gateway The prefix to access the API The destination spec type in this case AWS Lambda function named gloo-edge-hello-lambda The upstream that wil be used to route the request Let us create the virutal service, kubectl apply -n gloo-system -f $DEMO_HOME /apps/lambda/gloo/virtual-service.yaml Check the status of the virtual service glooctl get vs greeter +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+ | VIRTUAL SERVICE | DISPLAY NAME | DOMAINS | SSL | STATUS | LISTENERPLUGINS | ROUTES | +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+ | greeter | AWS Lambda Greeter | example.com | none | Accepted | | /greet -> | | | | | | | | gloo-system.gloo-edge-hello-lambda | | | | | | | | (upstream) | +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+","title":"Create Route"},{"location":"blog/#gloo-proxy-url","text":"We need to use the Gloo proxy to access the API, we can use glooctl to get the proxy URL, export GLOO_PROXY_URL = $( glooctl proxy url ) Important glooctl proxy url always returns the hostname of the Kubernetes nodes. You can check the hostnames using the command kubectl get nodes","title":"Gloo Proxy URL"},{"location":"blog/#resolve-nodes-via-etchosts","text":"Note You can ignore this section if your nodes are resolvable by their names Assuming that your VMC environment that does not have DNS resolver to resolve the EKS-A Kubernetes node names. In such caes we need to add the node names to the /etc/hosts file for them to be resolved. kubectl get nodes \\ -ojsonpath = \" {'#GLOO EDGE DEMO\\n'}{range .items[*]}{.status.addresses[?(@.type == 'ExternalIP')].address}{'\\t'}{.metadata.name}{'\\n'}{end}\" ) \\ | sudo tee --append /etc/hosts","title":"Resolve Nodes via /etc/hosts"},{"location":"blog/#invoke-function","text":"Check if the API is accessible, http --body POST $GLOO_PROXY_URL /greet 'Host: example.com' user = tom Note We have to use the host header \u2018Host: example.com\u2019 as we have restricted the gateway domains of the Virtual Service to example.com only. In the next chapter we will use the wildcard domain that will allow all the domains. The command should return a list of fruits as shown, { \"body\" : { \"message\" : \"Hello tom, welcome to Gloo Edge with Lambda.,\" }, \"statusCode\" : 200 } Tip Try the same request as show below to see the other repsonse headers http POST $GLOO_PROXY_URL /greet 'Host: example.com' user = tom","title":"Invoke Function"},{"location":"blog/#cleanup","text":"Delete the virtual service, glooctl delete vs greeter Delete the upstream, glooctl delete upstream gloo-edge-hello-lambda Delete AWS Lambda Function, aws lambda delete-function --function-name gloo-edge-hello-lambda Detach policy, aws iam detach-role-policy --role-name gloo-edge-eks-a-lambdaex \\ --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole Delete the Role, aws iam delete-role --role-name gloo-edge-eks-a-lambdaex Remove entries from /etc/hosts file, export NODE_COUNT = $( kubectl get nodes --no-headers | wc -l ) sudo sed -i -e '/#GLOO EDGE DEMO/,+' \" ${ NODE_COUNT } d\" /etc/hosts","title":"Cleanup"},{"location":"blog/#summary","text":"As part of this short blog we explored how to , Create a EKS-A cluster Deploy Gloo Edge Use GLoo Edge to invoke an AWS Lambda function Gloo Edge is not restricted to AWS Lambda, it can also be used to connect traditional microservices. Head over to the tutorial to learn more on what other thigns you can do with Gloo Edge. Any other CTA","title":"Summary"},{"location":"lambda/","text":"AWS Lambda \u00b6 Gloo Edge can act as gateway to AWS Lambda functions. At the end of this chapter you would have known how to: Create Gloo AWS Lambda Upstream Create Gloo Edge Gateway Configure Rate Limiting Configure WAF Pre-requsites \u00b6 AWS Account AWS Access Key AWS Secret Key Ensure Environment \u00b6 Note If you already have the environment variables set with same name, you can ignore this section If not set, Gloo Edge tends to compute these values from $HOME/.aws/credentials Its recommended to set these values for better clarity As we need to interact with AWS services, we will set the following environment variables, export AWS_ACCESS_KEY_ID = <your aws access key> export AWS_SECRET_ACCESS_KEY = <your aws secret key> export AWS_DEFAULT_REGION = <the aws region to use for the resources> Deploy AWS Lambda Function \u00b6 Create Role \u00b6 aws iam create-role --role-name gloo-edge-eks-a-lambdaex \\ --assume-role-policy-document \"file:// $DEMO_HOME /apps/lambda/trust-policy.json\" Save the Role ARN environment variable, export ROLE_ARN = $( aws iam get-role --role-name gloo-edge-eks-a-lambdaex | jq -r .Role.Arn ) Attach the AWSLambdaBasicExecutionRole to our role, aws iam attach-role-policy --role-name gloo-edge-eks-a-lambdaex \\ --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole Create Function \u00b6 The demo already has ready to deploy simple nodejs hello world application, exports . handler = async ( event ) => { const response = { statusCode : 200 , body : { \"message\" : `Hello ${ event . user ? event . user : \"there\" } , welcome to Gloo Edge with Lambda.,` }, }; return response ; }; Deploy the lambda, aws lambda create-function --function-name gloo-edge-hello-lambda \\ --zip-file \"fileb:// $DEMO_HOME /apps/lambda/function.zip\" \\ --handler index.handler \\ --runtime nodejs14.x \\ --role \" $ROLE_ARN \" Let us make sure our function works, aws lambda invoke \\ --cli-binary-format raw-in-base64-out \\ --function-name gloo-edge-hello-lambda \\ --payload '{\"user\": \"tom\"}' \\ response.json If the function has executed sucessfully, the $DEMO_HOME/response.json should have the following content, { \"statusCode\" : 200 , \"body\" : { \"message\" : \"Hello tom, welcome to Gloo Edge with Lambda.,\" } } Gloo Edge \u00b6 We have now deployed the AWS Lambda function, in the upcoming sections we will create the necessary Gloo Edge resources that will allow configure and access the Lambda via Gloo Edge Gateway. To have more understanding on the core concepts check the Traffic Management documentation. In the upcoming sections we will, Create AWS Secret Create Upstream Create Virtual Services Create AWS Secret \u00b6 We need to create Kubernetes secret that holds the AWS Keys. This secret will be used by Gloo Edge invoke the AWS Lambda function, glooctl create secret aws \\ --name = gloo-eks-a-demo \\ --access-key = \" $AWS_ACCESS_KEY_ID \" \\ --secret-key = \" $AWS_SECRET_ACCESS_KEY \" You can check the created credentials by, kubectl get secrets -n gloo-system gloo-eks-a-demo -o yaml Create Upstreams \u00b6 As part of this section we will create . Let us check to see if thats available, glooctl create upstream aws \\ --name = \"gloo-edge-hello-lambda\" \\ --aws-region = \" $AWS_DEFAULT_REGION \" \\ --aws-secret-name = gloo-eks-a-demo Check the status of the upstream, glooctl get upstream gloo-edge-hello-lambda +------------------------+------------+----------+--------------------------------+ | UPSTREAM | TYPE | STATUS | DETAILS | +------------------------+------------+----------+--------------------------------+ | gloo-edge-hello-lambda | AWS Lambda | Accepted | region: ap-south-1 | | | | | secret: | | | | | gloo-system.gloo-eks-a-demo | | | | | functions: | | | | | - gloo-edge-hello-lambda | | | | | - my-function | | | | | | +------------------------+------------+----------+--------------------------------+ Route \u00b6 A Route is a Gloo Virutal Service resource that allows us to access the API i.e. the services that are deployed on to Kubernetes. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : greeter namespace : gloo-system spec : displayName : AWS Lambda Greeter virtualHost : domains : # (1) - \"example.com\" routes : # Application Routes # ------------ - matchers : - prefix : /greet # (2) routeAction : single : destinationSpec : aws : # (3) logicalName : gloo-edge-hello-lambda # (4) upstream : # (5) name : gloo-edge-hello-lambda namespace : gloo-system Domains that will be allowed by the Gateway The prefix to access the API The destination spec type in this case AWS Lambda function named gloo-edge-hello-lambda The upstream that wil be used to route the request Let us create the virutal service, kubectl apply -n gloo-system -f $DEMO_HOME /apps/lambda/gloo/virtual-service.yaml Check the status of the virtual service glooctl get vs greeter +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+ | VIRTUAL SERVICE | DISPLAY NAME | DOMAINS | SSL | STATUS | LISTENERPLUGINS | ROUTES | +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+ | greeter | AWS Lambda Greeter | example.com | none | Accepted | | /greet -> | | | | | | | | gloo-system.gloo-edge-hello-lambda | | | | | | | | (upstream) | +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+ Invoke the API \u00b6 We need to use the Gloo proxy to access the API, we can use glooctl to get the proxy URL, export GLOO_PROXY_URL = $( glooctl proxy url ) Check if the API is accessible, http --body POST $GLOO_PROXY_URL /greet 'Host: example.com' user = tom Note We have to use the host header \u2018Host: example.com\u2019 as we have restricted the gateway domains of the Virtual Service to example.com only. In the next chapter we will use the wildcard domain that will allow all the domains. The command should return a list of fruits as shown, { \"body\" : { \"message\" : \"Hello tom, welcome to Gloo Edge with Lambda.,\" }, \"statusCode\" : 200 } Tip Try the same request as show below to see the other repsonse headers http POST $GLOO_PROXY_URL /greet 'Host: example.com' user = tom Rate Limit \u00b6 As part of this sectiobn we will configure Rate limiting . apiVersion : ratelimit.solo.io/v1alpha1 kind : RateLimitConfig metadata : name : lambda-global-limit namespace : gloo-system spec : raw : descriptors : - key : generic_key value : count rateLimit : requestsPerUnit : 10 #(1) unit : MINUTE #(1) rateLimits : - actions : - genericKey : descriptorValue : count Number of requests The duration for the request threshold, is this case 1 minute Let us apply the rate limiting configuration, kubectl apply -n gloo-system -f $DEMO_HOME /apps/lambda/gloo/ratelimit-config.yaml Update the service with ratelimit, kubectl apply -n gloo-system -f $DEMO_HOME /apps/lambda/gloo/virtual-service-ratelimit.yaml Let us now send requests to the API, with our current configuration we should start to get HTTP 429 once we exceed 10 requests, $DEMO_HOME /bin/greeter-poll.sh Wait for a minute or more, then try polling again to see the requests getting executed successfully until it reaches another set of 10 requests. Web Application Firewall \u00b6 A WAF protects web applications by monitoring, filtering and blocking potentially harmful traffic and attacks that can overtake or exploit them. Gloo Edge Enterprise includes the ability to enable the ModSecurity Web Application Firewall for any incoming and outgoing HTTP connections. For this demo, let us assume that our application will not support payload size of more than 1 byte , apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : greeter namespace : gloo-system spec : displayName : AWS Lambda Greeter virtualHost : domains : - \"example.com\" options : # -------- Web Application Firewall - Check User-Agent ----------- waf : # (1) ruleSets : # (2) - ruleStr : | # (3) SecRuleEngine On SecRequestBodyLimit 50 SecRequestBodyLimitAction Reject customInterventionMessage : \"Payload sizes above 50 bytes not allowed\" # (4) routes : # Application Routes # ------------ - matchers : - exact : /greet routeAction : single : destinationSpec : aws : logicalName : gloo-edge-hello-lambda upstream : name : gloo-edge-hello-lambda namespace : gloo-system options : # ---------------- Rate limit config ---------------------- rateLimitConfigs : refs : - name : lambda-global-limit namespace : gloo-system Define WAF rules The WAF block can have one or more ruleSets The rule inspects the payload size and if anything greater than 1 byte is rejected The message to display for rule voilations Let us update the Virtual Service with WAF enabled, kubectl apply -n gloo-system -f $DEMO_HOME /apps/lambda/gloo/virtual-service-waf.yaml Try request with payload more than 50 bytes : http POST $GLOO_PROXY_URL /greet 'Host: example.com' < $DEMO_HOME /apps/lambda/doc.json The request should with a response, HTTP/1.1 403 Forbidden content-length: 40 content-type: text/plain date: Wed, 18 Aug 2021 16:32:02 GMT server: envoy Payload sizes above 50 bytes not allowed Now try the same request with smaller payload size, which should succeeed. http POST $GLOO_PROXY_URL /greet 'Host: example.com' $GLOO_PROXY_URL /greet user = tom","title":"Gloo Edge with AWS Lambda"},{"location":"lambda/#aws-lambda","text":"Gloo Edge can act as gateway to AWS Lambda functions. At the end of this chapter you would have known how to: Create Gloo AWS Lambda Upstream Create Gloo Edge Gateway Configure Rate Limiting Configure WAF","title":"AWS Lambda"},{"location":"lambda/#pre-requsites","text":"AWS Account AWS Access Key AWS Secret Key","title":"Pre-requsites"},{"location":"lambda/#ensure-environment","text":"Note If you already have the environment variables set with same name, you can ignore this section If not set, Gloo Edge tends to compute these values from $HOME/.aws/credentials Its recommended to set these values for better clarity As we need to interact with AWS services, we will set the following environment variables, export AWS_ACCESS_KEY_ID = <your aws access key> export AWS_SECRET_ACCESS_KEY = <your aws secret key> export AWS_DEFAULT_REGION = <the aws region to use for the resources>","title":"Ensure Environment"},{"location":"lambda/#deploy-aws-lambda-function","text":"","title":"Deploy AWS Lambda Function"},{"location":"lambda/#create-role","text":"aws iam create-role --role-name gloo-edge-eks-a-lambdaex \\ --assume-role-policy-document \"file:// $DEMO_HOME /apps/lambda/trust-policy.json\" Save the Role ARN environment variable, export ROLE_ARN = $( aws iam get-role --role-name gloo-edge-eks-a-lambdaex | jq -r .Role.Arn ) Attach the AWSLambdaBasicExecutionRole to our role, aws iam attach-role-policy --role-name gloo-edge-eks-a-lambdaex \\ --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole","title":"Create Role"},{"location":"lambda/#create-function","text":"The demo already has ready to deploy simple nodejs hello world application, exports . handler = async ( event ) => { const response = { statusCode : 200 , body : { \"message\" : `Hello ${ event . user ? event . user : \"there\" } , welcome to Gloo Edge with Lambda.,` }, }; return response ; }; Deploy the lambda, aws lambda create-function --function-name gloo-edge-hello-lambda \\ --zip-file \"fileb:// $DEMO_HOME /apps/lambda/function.zip\" \\ --handler index.handler \\ --runtime nodejs14.x \\ --role \" $ROLE_ARN \" Let us make sure our function works, aws lambda invoke \\ --cli-binary-format raw-in-base64-out \\ --function-name gloo-edge-hello-lambda \\ --payload '{\"user\": \"tom\"}' \\ response.json If the function has executed sucessfully, the $DEMO_HOME/response.json should have the following content, { \"statusCode\" : 200 , \"body\" : { \"message\" : \"Hello tom, welcome to Gloo Edge with Lambda.,\" } }","title":"Create Function"},{"location":"lambda/#gloo-edge","text":"We have now deployed the AWS Lambda function, in the upcoming sections we will create the necessary Gloo Edge resources that will allow configure and access the Lambda via Gloo Edge Gateway. To have more understanding on the core concepts check the Traffic Management documentation. In the upcoming sections we will, Create AWS Secret Create Upstream Create Virtual Services","title":"Gloo Edge"},{"location":"lambda/#create-aws-secret","text":"We need to create Kubernetes secret that holds the AWS Keys. This secret will be used by Gloo Edge invoke the AWS Lambda function, glooctl create secret aws \\ --name = gloo-eks-a-demo \\ --access-key = \" $AWS_ACCESS_KEY_ID \" \\ --secret-key = \" $AWS_SECRET_ACCESS_KEY \" You can check the created credentials by, kubectl get secrets -n gloo-system gloo-eks-a-demo -o yaml","title":"Create AWS Secret"},{"location":"lambda/#create-upstreams","text":"As part of this section we will create . Let us check to see if thats available, glooctl create upstream aws \\ --name = \"gloo-edge-hello-lambda\" \\ --aws-region = \" $AWS_DEFAULT_REGION \" \\ --aws-secret-name = gloo-eks-a-demo Check the status of the upstream, glooctl get upstream gloo-edge-hello-lambda +------------------------+------------+----------+--------------------------------+ | UPSTREAM | TYPE | STATUS | DETAILS | +------------------------+------------+----------+--------------------------------+ | gloo-edge-hello-lambda | AWS Lambda | Accepted | region: ap-south-1 | | | | | secret: | | | | | gloo-system.gloo-eks-a-demo | | | | | functions: | | | | | - gloo-edge-hello-lambda | | | | | - my-function | | | | | | +------------------------+------------+----------+--------------------------------+","title":"Create Upstreams"},{"location":"lambda/#route","text":"A Route is a Gloo Virutal Service resource that allows us to access the API i.e. the services that are deployed on to Kubernetes. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : greeter namespace : gloo-system spec : displayName : AWS Lambda Greeter virtualHost : domains : # (1) - \"example.com\" routes : # Application Routes # ------------ - matchers : - prefix : /greet # (2) routeAction : single : destinationSpec : aws : # (3) logicalName : gloo-edge-hello-lambda # (4) upstream : # (5) name : gloo-edge-hello-lambda namespace : gloo-system Domains that will be allowed by the Gateway The prefix to access the API The destination spec type in this case AWS Lambda function named gloo-edge-hello-lambda The upstream that wil be used to route the request Let us create the virutal service, kubectl apply -n gloo-system -f $DEMO_HOME /apps/lambda/gloo/virtual-service.yaml Check the status of the virtual service glooctl get vs greeter +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+ | VIRTUAL SERVICE | DISPLAY NAME | DOMAINS | SSL | STATUS | LISTENERPLUGINS | ROUTES | +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+ | greeter | AWS Lambda Greeter | example.com | none | Accepted | | /greet -> | | | | | | | | gloo-system.gloo-edge-hello-lambda | | | | | | | | (upstream) | +-----------------+--------------------+-------------+------+----------+-----------------+------------------------------------+","title":"Route"},{"location":"lambda/#invoke-the-api","text":"We need to use the Gloo proxy to access the API, we can use glooctl to get the proxy URL, export GLOO_PROXY_URL = $( glooctl proxy url ) Check if the API is accessible, http --body POST $GLOO_PROXY_URL /greet 'Host: example.com' user = tom Note We have to use the host header \u2018Host: example.com\u2019 as we have restricted the gateway domains of the Virtual Service to example.com only. In the next chapter we will use the wildcard domain that will allow all the domains. The command should return a list of fruits as shown, { \"body\" : { \"message\" : \"Hello tom, welcome to Gloo Edge with Lambda.,\" }, \"statusCode\" : 200 } Tip Try the same request as show below to see the other repsonse headers http POST $GLOO_PROXY_URL /greet 'Host: example.com' user = tom","title":"Invoke the API"},{"location":"lambda/#rate-limit","text":"As part of this sectiobn we will configure Rate limiting . apiVersion : ratelimit.solo.io/v1alpha1 kind : RateLimitConfig metadata : name : lambda-global-limit namespace : gloo-system spec : raw : descriptors : - key : generic_key value : count rateLimit : requestsPerUnit : 10 #(1) unit : MINUTE #(1) rateLimits : - actions : - genericKey : descriptorValue : count Number of requests The duration for the request threshold, is this case 1 minute Let us apply the rate limiting configuration, kubectl apply -n gloo-system -f $DEMO_HOME /apps/lambda/gloo/ratelimit-config.yaml Update the service with ratelimit, kubectl apply -n gloo-system -f $DEMO_HOME /apps/lambda/gloo/virtual-service-ratelimit.yaml Let us now send requests to the API, with our current configuration we should start to get HTTP 429 once we exceed 10 requests, $DEMO_HOME /bin/greeter-poll.sh Wait for a minute or more, then try polling again to see the requests getting executed successfully until it reaches another set of 10 requests.","title":"Rate Limit"},{"location":"lambda/#web-application-firewall","text":"A WAF protects web applications by monitoring, filtering and blocking potentially harmful traffic and attacks that can overtake or exploit them. Gloo Edge Enterprise includes the ability to enable the ModSecurity Web Application Firewall for any incoming and outgoing HTTP connections. For this demo, let us assume that our application will not support payload size of more than 1 byte , apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : greeter namespace : gloo-system spec : displayName : AWS Lambda Greeter virtualHost : domains : - \"example.com\" options : # -------- Web Application Firewall - Check User-Agent ----------- waf : # (1) ruleSets : # (2) - ruleStr : | # (3) SecRuleEngine On SecRequestBodyLimit 50 SecRequestBodyLimitAction Reject customInterventionMessage : \"Payload sizes above 50 bytes not allowed\" # (4) routes : # Application Routes # ------------ - matchers : - exact : /greet routeAction : single : destinationSpec : aws : logicalName : gloo-edge-hello-lambda upstream : name : gloo-edge-hello-lambda namespace : gloo-system options : # ---------------- Rate limit config ---------------------- rateLimitConfigs : refs : - name : lambda-global-limit namespace : gloo-system Define WAF rules The WAF block can have one or more ruleSets The rule inspects the payload size and if anything greater than 1 byte is rejected The message to display for rule voilations Let us update the Virtual Service with WAF enabled, kubectl apply -n gloo-system -f $DEMO_HOME /apps/lambda/gloo/virtual-service-waf.yaml Try request with payload more than 50 bytes : http POST $GLOO_PROXY_URL /greet 'Host: example.com' < $DEMO_HOME /apps/lambda/doc.json The request should with a response, HTTP/1.1 403 Forbidden content-length: 40 content-type: text/plain date: Wed, 18 Aug 2021 16:32:02 GMT server: envoy Payload sizes above 50 bytes not allowed Now try the same request with smaller payload size, which should succeeed. http POST $GLOO_PROXY_URL /greet 'Host: example.com' $GLOO_PROXY_URL /greet user = tom","title":"Web Application Firewall"},{"location":"microservice/","text":"Deploy App \u00b6 The demo application that will be deployed is a simple Fruits microservice. The source code the Fruits API is available here . At the end of this chapter you would have known how to: Create Gloo Edge Gateway Configure Rate Limiting Configure WAF Configure CORS Deploy Database \u00b6 kubectl apply -k $DEMO_HOME /apps/microservice/fruits-api/db Wait for the DB to be up kubectl rollout status -n db deploy/postgresql --timeout = 60s Waiting for deployment \u201cpostgresql\u201d rollout to finish: 0 of 1 updated replicas are available\u2026 deployment \u201cpostgresql\u201d successfully rolled out Deploy REST API \u00b6 kubectl apply -k $DEMO_HOME /apps/microservice/fruits-api/app Wait for the REST API to be up kubectl rollout status -n fruits-app deploy/fruits-api --timeout = 60s Waiting for deployment \u201cfruits-api\u201d rollout to finish: 0 of 1 updated replicas are available\u2026 deployment \u201cfruits-api\u201d successfully rolled out Gloo Edge \u00b6 We have now deployed the Fruits API, in the up coming sections we will create the necessary Gloo Edge resources that will allow configure and access the API. To have more understanding on the core concepts check the Traffic Management documentation. In the upcoming sections we will, Discover Upstreams Create Virtual Services Upstreams \u00b6 The Gloo Edge installation that as done as part of the demo is enabled to do auto discovery of the upstreams. The Fruits API that we deployed earlier would have been discovered as fruits-app-fruits-api-8080 . Let us check to see if thats available, glooctl get upstream fruits-app-fruits-api-8080 -----------------------------------------------------------------------------+ | UPSTREAM | TYPE | STATUS | DETAILS | -----------------------------------------------------------------------------+ | fruits-app-fruits-api-8080 | Kubernetes | Accepted | svc name: fruits-api | | | | | svc namespace: fruits-app | | | | | port: 8080 | | | | | | -----------------------------------------------------------------------------+ Route \u00b6 A Route is a Gloo Virutal Service resource that allows us to access the API i.e. the services that are deployed on to Kubernetes. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : domains : # (1) - \"*\" routes : # Application Routes # ------------ - matchers : - prefix : /api/ #(2) routeAction : single : upstream : #(3) name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ #(4) Domains that will be allowed by the Gateway The prefix to access the API The upstream that wil be used to route the request The url rewrite to do before passing the request to backend Let us create the virutal service, kubectl apply -n gloo-system -f $DEMO_HOME /apps/microservice/fruits-api/gloo/virtual-service.yaml Check the status of the virtual service glooctl get vs fruits-api ---------------------------------------------------------------------------------------------- | VIRTUAL SERVICE | DISPLAY NAME | DOMAINS | SSL | STATUS | LISTENERPLUGINS | ROUTES | ---------------------------------------------------------------------------------------------- | fruits-api | | * | none | Accepted | | / -> 1 destinations | ---------------------------------------------------------------------------------------------- Invoke API \u00b6 We need to use the Gloo proxy to access the API, we can use glooctl to get the proxy URL, export GLOO_PROXY_URL = $( glooctl proxy url ) Check if the API is accessible, http $GLOO_PROXY_URL /api/fruits/ The command should return a list of fruits as shown, [ { \"id\" : 8 , \"name\" : \"Apple\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F34E\" }, { \"id\" : 6 , \"name\" : \"Banana\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F34C\" }, { \"id\" : 5 , \"name\" : \"Blueberry\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1FAD0\" }, { \"id\" : 4 , \"name\" : \"Lemon\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34B\" }, { \"id\" : 1 , \"name\" : \"Mango\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F96D\" }, { \"id\" : 3 , \"name\" : \"Orange\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34A\" }, { \"id\" : 9 , \"name\" : \"Pear\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F350\" }, { \"id\" : 2 , \"name\" : \"Strawberry\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F353\" }, { \"id\" : 7 , \"name\" : \"Watermelon\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F349\" } ] Rate Limit \u00b6 As part of this sectiobn we will configure Rate limiting . apiVersion : ratelimit.solo.io/v1alpha1 kind : RateLimitConfig metadata : name : global-limit namespace : gloo-system spec : raw : descriptors : - key : generic_key value : count rateLimit : requestsPerUnit : 10 #(1) unit : MINUTE #(1) rateLimits : - actions : - genericKey : descriptorValue : count Number of requests The duration for the request threshold, is this case 1 minute Let us apply the rate limiting configuration, kubectl apply -n gloo-system -f $DEMO_HOME /apps/microservice/fruits-api/gloo/ratelimit-config.yaml Update the service with ratelimit, kubectl apply -n gloo-system -f $DEMO_HOME /apps/microservice/fruits-api/gloo/virtual-service-ratelimit.yaml Let us now send requests to the API, with our current configuration we should start to get HTTP 429 once we exceed 10 requests, $DEMO_HOME /bin/poll.sh Wait for a minute more to try polling again to see the requests getting executed successfully. Web Application Firewall \u00b6 A WAF protects web applications by monitoring, filtering and blocking potentially harmful traffic and attacks that can overtake or exploit them. Gloo Edge Enterprise includes the ability to enable the ModSecurity Web Application Firewall for any incoming and outgoing HTTP connections. For this demo, let us assume that our application does not support Firefox yet so for any requests that come with Firefox browser agent need to be blocked and informed. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : options : # -------- Web Application Firewall - Check User-Agent ----------- waf : # (1) ruleSets : # (2) - ruleStr : | # (3) SecRuleEngine On SecRule REQUEST_HEADERS:User-Agent \".*Firefox.*\" \"deny,status:403,id:107,phase:1,msg:'unsupported user agent'\" customInterventionMessage : \"Firefox not supported\" # (4) domains : - \"*\" routes : # --------------------- Application Routes ----------------- - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ # ---------------- Rate limit config ---------------------- rateLimitConfigs : refs : - name : global-limit namespace : gloo-system Define WAF rules The WAF block can have one or more ruleSets The rule inspects the User-Agent header The message to display for rule voilations Let us update the Virtual Service with WAF enabled, kubectl apply -n gloo-system -f $DEMO_HOME /apps/microservice/fruits-api/gloo/virtual-service-waf.yaml Try simulating the API request as if it was generated from Firefox browser: http $GLOO_PROXY_URL /api/fruits/ User-Agent:Firefox The request should with a response, HTTP/1.1 403 Forbidden content-length: 21 content-type: text/plain date: Wed, 18 Aug 2021 11:24:46 GMT server: envoy Firefox not supported No try the same request with any other user agent which should succeed. http $GLOO_PROXY_URL /api/fruits/ User-Agent:Safari CORS \u00b6 Gloo Edge also supports configuring the CORS policies without the need to redeploy the backend API application. As part of this section we will extend our demo Fruits API with simple SPA . Build the UI Application \u00b6 Since the SPA are accessed from browser we need to rebuild the UI with th GLOO_PROXY_URL that the application need to use, docker build --build-arg = \"GLOO_PROXY_URL= $GLOO_PROXY_URL \" \\ -t example/fruits-ui \\ -f $DEMO_HOME /Dockerfile-UI $DEMO_HOME Once the contianer is built let us run it, docker run --rm -p 8085 :8080 example/fruits-ui When you open the localhost:8085 in the browser you will see application page like When you open the browser\u2019 developer tools console, you should notice the CORS errors like: Update Virtual Service \u00b6 To fix this we need to update the Virutal Service with CORS options, apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : options : # -------- CORS Config ----------- cors : # (1) allowOriginRegex : - '^http(s)?:\\/\\/localhost:[0-9]{4,5}$' # (2) allowHeaders : # (3) - origin - content-type allowMethods : # (4) - DELETE maxAge : 1d # -------- Web Application Firewall - Check User-Agent ----------- waf : customInterventionMessage : \"Firefox not supported\" ruleSets : - ruleStr : | SecRuleEngine On SecRule REQUEST_HEADERS:User-Agent \".*Firefox.*\" \"deny,status:403,id:107,phase:1,msg:'unsupported user agent'\" domains : - \"*\" routes : # --------------------- Application Routes ----------------- - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ # ---------------- Rate limit config ---------------------- rateLimitConfigs : refs : - name : global-limit namespace : gloo-system Enable CORS options The Origin Regular Expression, this will allow all localhost The CORS headers that are allowed The methods that the orgins can excute Now let us update the virtual service, kubectl apply -n gloo-system -f $DEMO_HOME /apps/microservice/fruits-api/gloo/virtual-service-cors.yaml Now try refreshing the browser url localhost:8085 and you will see a list of fruits as shown without any CORS errors.","title":"Gloo Edge with Microservice"},{"location":"microservice/#deploy-app","text":"The demo application that will be deployed is a simple Fruits microservice. The source code the Fruits API is available here . At the end of this chapter you would have known how to: Create Gloo Edge Gateway Configure Rate Limiting Configure WAF Configure CORS","title":"Deploy App"},{"location":"microservice/#deploy-database","text":"kubectl apply -k $DEMO_HOME /apps/microservice/fruits-api/db Wait for the DB to be up kubectl rollout status -n db deploy/postgresql --timeout = 60s Waiting for deployment \u201cpostgresql\u201d rollout to finish: 0 of 1 updated replicas are available\u2026 deployment \u201cpostgresql\u201d successfully rolled out","title":"Deploy Database"},{"location":"microservice/#deploy-rest-api","text":"kubectl apply -k $DEMO_HOME /apps/microservice/fruits-api/app Wait for the REST API to be up kubectl rollout status -n fruits-app deploy/fruits-api --timeout = 60s Waiting for deployment \u201cfruits-api\u201d rollout to finish: 0 of 1 updated replicas are available\u2026 deployment \u201cfruits-api\u201d successfully rolled out","title":"Deploy REST API"},{"location":"microservice/#gloo-edge","text":"We have now deployed the Fruits API, in the up coming sections we will create the necessary Gloo Edge resources that will allow configure and access the API. To have more understanding on the core concepts check the Traffic Management documentation. In the upcoming sections we will, Discover Upstreams Create Virtual Services","title":"Gloo Edge"},{"location":"microservice/#upstreams","text":"The Gloo Edge installation that as done as part of the demo is enabled to do auto discovery of the upstreams. The Fruits API that we deployed earlier would have been discovered as fruits-app-fruits-api-8080 . Let us check to see if thats available, glooctl get upstream fruits-app-fruits-api-8080 -----------------------------------------------------------------------------+ | UPSTREAM | TYPE | STATUS | DETAILS | -----------------------------------------------------------------------------+ | fruits-app-fruits-api-8080 | Kubernetes | Accepted | svc name: fruits-api | | | | | svc namespace: fruits-app | | | | | port: 8080 | | | | | | -----------------------------------------------------------------------------+","title":"Upstreams"},{"location":"microservice/#route","text":"A Route is a Gloo Virutal Service resource that allows us to access the API i.e. the services that are deployed on to Kubernetes. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : domains : # (1) - \"*\" routes : # Application Routes # ------------ - matchers : - prefix : /api/ #(2) routeAction : single : upstream : #(3) name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ #(4) Domains that will be allowed by the Gateway The prefix to access the API The upstream that wil be used to route the request The url rewrite to do before passing the request to backend Let us create the virutal service, kubectl apply -n gloo-system -f $DEMO_HOME /apps/microservice/fruits-api/gloo/virtual-service.yaml Check the status of the virtual service glooctl get vs fruits-api ---------------------------------------------------------------------------------------------- | VIRTUAL SERVICE | DISPLAY NAME | DOMAINS | SSL | STATUS | LISTENERPLUGINS | ROUTES | ---------------------------------------------------------------------------------------------- | fruits-api | | * | none | Accepted | | / -> 1 destinations | ----------------------------------------------------------------------------------------------","title":"Route"},{"location":"microservice/#invoke-api","text":"We need to use the Gloo proxy to access the API, we can use glooctl to get the proxy URL, export GLOO_PROXY_URL = $( glooctl proxy url ) Check if the API is accessible, http $GLOO_PROXY_URL /api/fruits/ The command should return a list of fruits as shown, [ { \"id\" : 8 , \"name\" : \"Apple\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F34E\" }, { \"id\" : 6 , \"name\" : \"Banana\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F34C\" }, { \"id\" : 5 , \"name\" : \"Blueberry\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1FAD0\" }, { \"id\" : 4 , \"name\" : \"Lemon\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34B\" }, { \"id\" : 1 , \"name\" : \"Mango\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F96D\" }, { \"id\" : 3 , \"name\" : \"Orange\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34A\" }, { \"id\" : 9 , \"name\" : \"Pear\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F350\" }, { \"id\" : 2 , \"name\" : \"Strawberry\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F353\" }, { \"id\" : 7 , \"name\" : \"Watermelon\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F349\" } ]","title":"Invoke API"},{"location":"microservice/#rate-limit","text":"As part of this sectiobn we will configure Rate limiting . apiVersion : ratelimit.solo.io/v1alpha1 kind : RateLimitConfig metadata : name : global-limit namespace : gloo-system spec : raw : descriptors : - key : generic_key value : count rateLimit : requestsPerUnit : 10 #(1) unit : MINUTE #(1) rateLimits : - actions : - genericKey : descriptorValue : count Number of requests The duration for the request threshold, is this case 1 minute Let us apply the rate limiting configuration, kubectl apply -n gloo-system -f $DEMO_HOME /apps/microservice/fruits-api/gloo/ratelimit-config.yaml Update the service with ratelimit, kubectl apply -n gloo-system -f $DEMO_HOME /apps/microservice/fruits-api/gloo/virtual-service-ratelimit.yaml Let us now send requests to the API, with our current configuration we should start to get HTTP 429 once we exceed 10 requests, $DEMO_HOME /bin/poll.sh Wait for a minute more to try polling again to see the requests getting executed successfully.","title":"Rate Limit"},{"location":"microservice/#web-application-firewall","text":"A WAF protects web applications by monitoring, filtering and blocking potentially harmful traffic and attacks that can overtake or exploit them. Gloo Edge Enterprise includes the ability to enable the ModSecurity Web Application Firewall for any incoming and outgoing HTTP connections. For this demo, let us assume that our application does not support Firefox yet so for any requests that come with Firefox browser agent need to be blocked and informed. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : options : # -------- Web Application Firewall - Check User-Agent ----------- waf : # (1) ruleSets : # (2) - ruleStr : | # (3) SecRuleEngine On SecRule REQUEST_HEADERS:User-Agent \".*Firefox.*\" \"deny,status:403,id:107,phase:1,msg:'unsupported user agent'\" customInterventionMessage : \"Firefox not supported\" # (4) domains : - \"*\" routes : # --------------------- Application Routes ----------------- - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ # ---------------- Rate limit config ---------------------- rateLimitConfigs : refs : - name : global-limit namespace : gloo-system Define WAF rules The WAF block can have one or more ruleSets The rule inspects the User-Agent header The message to display for rule voilations Let us update the Virtual Service with WAF enabled, kubectl apply -n gloo-system -f $DEMO_HOME /apps/microservice/fruits-api/gloo/virtual-service-waf.yaml Try simulating the API request as if it was generated from Firefox browser: http $GLOO_PROXY_URL /api/fruits/ User-Agent:Firefox The request should with a response, HTTP/1.1 403 Forbidden content-length: 21 content-type: text/plain date: Wed, 18 Aug 2021 11:24:46 GMT server: envoy Firefox not supported No try the same request with any other user agent which should succeed. http $GLOO_PROXY_URL /api/fruits/ User-Agent:Safari","title":"Web Application Firewall"},{"location":"microservice/#cors","text":"Gloo Edge also supports configuring the CORS policies without the need to redeploy the backend API application. As part of this section we will extend our demo Fruits API with simple SPA .","title":"CORS"},{"location":"microservice/#build-the-ui-application","text":"Since the SPA are accessed from browser we need to rebuild the UI with th GLOO_PROXY_URL that the application need to use, docker build --build-arg = \"GLOO_PROXY_URL= $GLOO_PROXY_URL \" \\ -t example/fruits-ui \\ -f $DEMO_HOME /Dockerfile-UI $DEMO_HOME Once the contianer is built let us run it, docker run --rm -p 8085 :8080 example/fruits-ui When you open the localhost:8085 in the browser you will see application page like When you open the browser\u2019 developer tools console, you should notice the CORS errors like:","title":"Build the UI Application"},{"location":"microservice/#update-virtual-service","text":"To fix this we need to update the Virutal Service with CORS options, apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : options : # -------- CORS Config ----------- cors : # (1) allowOriginRegex : - '^http(s)?:\\/\\/localhost:[0-9]{4,5}$' # (2) allowHeaders : # (3) - origin - content-type allowMethods : # (4) - DELETE maxAge : 1d # -------- Web Application Firewall - Check User-Agent ----------- waf : customInterventionMessage : \"Firefox not supported\" ruleSets : - ruleStr : | SecRuleEngine On SecRule REQUEST_HEADERS:User-Agent \".*Firefox.*\" \"deny,status:403,id:107,phase:1,msg:'unsupported user agent'\" domains : - \"*\" routes : # --------------------- Application Routes ----------------- - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ # ---------------- Rate limit config ---------------------- rateLimitConfigs : refs : - name : global-limit namespace : gloo-system Enable CORS options The Origin Regular Expression, this will allow all localhost The CORS headers that are allowed The methods that the orgins can excute Now let us update the virtual service, kubectl apply -n gloo-system -f $DEMO_HOME /apps/microservice/fruits-api/gloo/virtual-service-cors.yaml Now try refreshing the browser url localhost:8085 and you will see a list of fruits as shown without any CORS errors.","title":"Update Virtual Service"},{"location":"setup/","text":"Cluster Setup \u00b6 At the end of this chapter you will have working eks-a cluster with Gloo Edge Enterprise installed and configured. Pre-requisites \u00b6 eks-a glooctl jq kubectl kustomize Gloo Edge Enterprise License Key VMWare Cloud Demo Sources \u00b6 Clone the demo sources from the GitHub respository, git clone https://github.com/kameshsampath/gloo-edge-eks-a-demo cd gloo-edge-eks-a-demo For convinience, we will refer the clone demo sources folder as $DEMO_HOME , export DEMO_HOME = \" $( pwd ) \" EKS-A Cluster \u00b6 To create the EKS-A cluster run the following command, eks-a create cluster -f cluster/gloo-edge.yaml # (1) gloo-edge.yaml - will be generated using the eks-a generate command. For more information on the command please refer to TODO Link to eks-a docs . Configure Storage Class \u00b6 The demo clusters does not have default storage provisoners or storage class defined. For this demo we will use rancher\u2019s local-path-provisoner . kubectl apply \\ -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml Wait for the storage provisioner to be ready, kubectl rollout status -n local-path-storage deploy/local-path-provisioner --timeout = 60s Set it as default storage class kubectl patch storageclass local-path \\ -p '{\"metadata\": {\"annotations\":{\"storageclass.kubernetes.io/is-default-class\":\"true\"}}}' Install Gloo Edge Enterprise \u00b6 Download and install latest glooctl by running, curl -sL https://run.solo.io/gloo/install | sh Add glooctl to the system path, export PATH = $HOME /.gloo/bin: $PATH Gloo Edge proxy is a Kubernetes service of type LoadBalancer , for the purpose of this blog we will configure it to be of type NodePort as shown below, gloo : settings : writeNamespace : gloo-system watchNamespace : - gloo-system - fruits-app gatewayProxies : gatewayProxy : service : type : NodePort httpNodePort : 30080 # (1) httpsNodePort : 30443 # (2) Use 30080 as NodePort to access the Gloo Proxy Use 30443 as NodePort to access the Gloo Proxy glooctl install gateway enterprise \\ --license-key \" $GLOO_LICENSE_KEY \" \\ --values \" $DEMO_HOME /cluster/install-ee-values.yaml\" Note You can safely ignore the helm warnings The Gloo Edge is also configured to use NodePort for proxy,that will help to access the Gloo Gateway proxy using node port. This configuration is set via install-ee-values.yaml . It will take few minutes for the gloo to be ready, try the command glooctl check to verify the status. Once the gloo edge is deployed check if Gloo Edge is functional, glooctl check A successful gloo edge installation should show an output like, Checking deployments... OK Checking pods... OK Checking upstreams... OK Checking upstream groups... OK Checking auth configs... OK Checking rate limit configs... OK Checking VirtualHostOptions... OK Checking RouteOptions... OK Checking secrets... OK Checking virtual services... OK Checking gateways... OK Checking proxies... OK Checking rate limit server... OK No problems detected. I0818 09:29:26.773174 6734 request.go:645] Throttling request took 1.041899775s, request: GET:https://127.0.0.1:57778/apis/storage.k8s.io/v1?timeout=32s Detected Gloo Federation!","title":"Setup"},{"location":"setup/#cluster-setup","text":"At the end of this chapter you will have working eks-a cluster with Gloo Edge Enterprise installed and configured.","title":"Cluster Setup"},{"location":"setup/#pre-requisites","text":"eks-a glooctl jq kubectl kustomize Gloo Edge Enterprise License Key VMWare Cloud","title":"Pre-requisites"},{"location":"setup/#demo-sources","text":"Clone the demo sources from the GitHub respository, git clone https://github.com/kameshsampath/gloo-edge-eks-a-demo cd gloo-edge-eks-a-demo For convinience, we will refer the clone demo sources folder as $DEMO_HOME , export DEMO_HOME = \" $( pwd ) \"","title":"Demo Sources"},{"location":"setup/#eks-a-cluster","text":"To create the EKS-A cluster run the following command, eks-a create cluster -f cluster/gloo-edge.yaml # (1) gloo-edge.yaml - will be generated using the eks-a generate command. For more information on the command please refer to TODO Link to eks-a docs .","title":"EKS-A Cluster"},{"location":"setup/#configure-storage-class","text":"The demo clusters does not have default storage provisoners or storage class defined. For this demo we will use rancher\u2019s local-path-provisoner . kubectl apply \\ -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml Wait for the storage provisioner to be ready, kubectl rollout status -n local-path-storage deploy/local-path-provisioner --timeout = 60s Set it as default storage class kubectl patch storageclass local-path \\ -p '{\"metadata\": {\"annotations\":{\"storageclass.kubernetes.io/is-default-class\":\"true\"}}}'","title":"Configure Storage Class"},{"location":"setup/#install-gloo-edge-enterprise","text":"Download and install latest glooctl by running, curl -sL https://run.solo.io/gloo/install | sh Add glooctl to the system path, export PATH = $HOME /.gloo/bin: $PATH Gloo Edge proxy is a Kubernetes service of type LoadBalancer , for the purpose of this blog we will configure it to be of type NodePort as shown below, gloo : settings : writeNamespace : gloo-system watchNamespace : - gloo-system - fruits-app gatewayProxies : gatewayProxy : service : type : NodePort httpNodePort : 30080 # (1) httpsNodePort : 30443 # (2) Use 30080 as NodePort to access the Gloo Proxy Use 30443 as NodePort to access the Gloo Proxy glooctl install gateway enterprise \\ --license-key \" $GLOO_LICENSE_KEY \" \\ --values \" $DEMO_HOME /cluster/install-ee-values.yaml\" Note You can safely ignore the helm warnings The Gloo Edge is also configured to use NodePort for proxy,that will help to access the Gloo Gateway proxy using node port. This configuration is set via install-ee-values.yaml . It will take few minutes for the gloo to be ready, try the command glooctl check to verify the status. Once the gloo edge is deployed check if Gloo Edge is functional, glooctl check A successful gloo edge installation should show an output like, Checking deployments... OK Checking pods... OK Checking upstreams... OK Checking upstream groups... OK Checking auth configs... OK Checking rate limit configs... OK Checking VirtualHostOptions... OK Checking RouteOptions... OK Checking secrets... OK Checking virtual services... OK Checking gateways... OK Checking proxies... OK Checking rate limit server... OK No problems detected. I0818 09:29:26.773174 6734 request.go:645] Throttling request took 1.041899775s, request: GET:https://127.0.0.1:57778/apis/storage.k8s.io/v1?timeout=32s Detected Gloo Federation!","title":"Install Gloo Edge Enterprise"}]}